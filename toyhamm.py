
# Author:Colin 
# Date Nov 18 2013 
# Testing simple Hamming code for C(39,32),C(72,64),C(137,128),C(266,256) 
# UPDATE: Nov 20 2013: Include DED functionality by overall parity bit ;
# use error_status_code to switch to error scenarios detected 
#TODO: larger G/H for wider information word length 







import numpy
import random
# import sys

#parity matrix is in G=[I,P] so H=[P',I] 
p16 = numpy.array(
[[1,0,1,0,0],
[0,1,0,1,0],
[0,0,1,0,1],
[1,0,1,1,0],
[0,1,0,1,1],
[1,0,0,0,1],
[1,1,1,0,0],
[0,1,1,1,0],
[0,0,1,1,1],
[1,0,1,1,1],
[1,1,1,1,1],
[1,1,0,1,1],
[1,1,0,0,1],
[1,1,0,0,0],
[0,1,1,0,0],
[0,0,1,1,0]], dtype=int 
)



p32 = numpy.array(
[[1,1,0,0,0,0],
[0,1,1,0,0,0],
[0,0,1,1,0,0],
[0,0,0,1,1,0],
[0,0,0,0,1,1],
[1,1,0,0,0,1],
[1,0,1,0,0,0],
[0,1,0,1,0,0],
[0,0,1,0,1,0],
[0,0,0,1,0,1],
[1,1,0,0,1,0],
[0,1,1,0,0,1],
[1,1,1,1,0,0],
[0,1,1,1,1,0],
[0,0,1,1,1,1],
[1,1,0,1,1,1],
[1,0,1,0,1,1],
[1,0,0,1,0,1],
[1,0,0,0,1,0],
[0,1,0,0,0,1],
[1,1,1,0,0,0],
[0,1,1,1,0,0],
[0,0,1,1,1,0],
[0,0,0,1,1,1],
[1,1,0,0,1,1],
[1,0,1,0,0,1],
[1,0,0,1,0,0],
[0,1,0,0,1,0],
[0,0,1,0,0,1],
[1,1,0,1,0,0],
[0,1,1,0,1,0],
[0,0,1,1,0,1]] , dtype=int) # Parity submatrix 32X6 for word size 32

p64=numpy.array(
[[1,0,0,1,0,0,0],
[0,1,0,0,1,0,0],
[0,0,1,0,0,1,0],
[0,0,0,1,0,0,1],
[1,0,0,1,1,0,0],
[0,1,0,0,1,1,0],
[0,0,1,0,0,1,1],
[1,0,0,0,0,0,1],
[1,1,0,1,0,0,0],
[0,1,1,0,1,0,0],
[0,0,1,1,0,1,0],
[0,0,0,1,1,0,1],
[1,0,0,1,1,1,0],
[0,1,0,0,1,1,1],
[1,0,1,1,0,1,1],
[1,1,0,0,1,0,1],
[1,1,1,1,0,1,0],
[0,1,1,1,1,0,1],
[1,0,1,0,1,1,0],
[0,1,0,1,0,1,1],
[1,0,1,1,1,0,1],
[1,1,0,0,1,1,0],
[0,1,1,0,0,1,1],
[1,0,1,0,0,0,1],
[1,1,0,0,0,0,0],
[0,1,1,0,0,0,0],
[0,0,1,1,0,0,0],
[0,0,0,1,1,0,0],
[0,0,0,0,1,1,0],
[0,0,0,0,0,1,1],
[1,0,0,1,0,0,1],
[1,1,0,1,1,0,0],
[0,1,1,0,1,1,0],
[0,0,1,1,0,1,1],
[1,0,0,0,1,0,1],
[1,1,0,1,0,1,0],
[0,1,1,0,1,0,1],
[1,0,1,0,0,1,0],
[0,1,0,1,0,0,1],
[1,0,1,1,1,0,0],
[0,1,0,1,1,1,0],
[0,0,1,0,1,1,1],
[1,0,0,0,0,1,1],
[1,1,0,1,0,0,1],
[1,1,1,1,1,0,0],
[0,1,1,1,1,1,0],
[0,0,1,1,1,1,1],
[1,0,0,0,1,1,1],
[1,1,0,1,0,1,1],
[1,1,1,1,1,0,1],
[1,1,1,0,1,1,0],
[0,1,1,1,0,1,1],
[1,0,1,0,1,0,1],
[1,1,0,0,0,1,0],
[0,1,1,0,0,0,1],
[1,0,1,0,0,0,0],
[0,1,0,1,0,0,0],
[0,0,1,0,1,0,0],
[0,0,0,1,0,1,0],
[0,0,0,0,1,0,1],
[1,0,0,1,0,1,0],
[0,1,0,0,1,0,1],
[1,0,1,1,0,1,0],
[0,1,0,1,1,0,1]], dtype = int ) 


p128 = numpy.array(
[[1,0,1,1,1,0,0,0],
[0,1,0,1,1,1,0,0],
[0,0,1,0,1,1,1,0],
[0,0,0,1,0,1,1,1],
[1,0,1,1,0,0,1,1],
[1,1,1,0,0,0,0,1],
[1,1,0,0,1,0,0,0],
[0,1,1,0,0,1,0,0],
[0,0,1,1,0,0,1,0],
[0,0,0,1,1,0,0,1],
[1,0,1,1,0,1,0,0],
[0,1,0,1,1,0,1,0],
[0,0,1,0,1,1,0,1],
[1,0,1,0,1,1,1,0],
[0,1,0,1,0,1,1,1],
[1,0,0,1,0,0,1,1],
[1,1,1,1,0,0,0,1],
[1,1,0,0,0,0,0,0],
[0,1,1,0,0,0,0,0],
[0,0,1,1,0,0,0,0],
[0,0,0,1,1,0,0,0],
[0,0,0,0,1,1,0,0],
[0,0,0,0,0,1,1,0],
[0,0,0,0,0,0,1,1],
[1,0,1,1,1,0,0,1],
[1,1,1,0,0,1,0,0],
[0,1,1,1,0,0,1,0],
[0,0,1,1,1,0,0,1],
[1,0,1,0,0,1,0,0],
[0,1,0,1,0,0,1,0],
[0,0,1,0,1,0,0,1],
[1,0,1,0,1,1,0,0],
[0,1,0,1,0,1,1,0],
[0,0,1,0,1,0,1,1],
[1,0,1,0,1,1,0,1],
[1,1,1,0,1,1,1,0],
[0,1,1,1,0,1,1,1],
[1,0,0,0,0,0,1,1],
[1,1,1,1,1,0,0,1],
[1,1,0,0,0,1,0,0],
[0,1,1,0,0,0,1,0],
[0,0,1,1,0,0,0,1],
[1,0,1,0,0,0,0,0],
[0,1,0,1,0,0,0,0],
[0,0,1,0,1,0,0,0],
[0,0,0,1,0,1,0,0],
[0,0,0,0,1,0,1,0],
[0,0,0,0,0,1,0,1],
[1,0,1,1,1,0,1,0],
[0,1,0,1,1,1,0,1],
[1,0,0,1,0,1,1,0],
[0,1,0,0,1,0,1,1],
[1,0,0,1,1,1,0,1],
[1,1,1,1,0,1,1,0],
[0,1,1,1,1,0,1,1],
[1,0,0,0,0,1,0,1],
[1,1,1,1,1,0,1,0],
[0,1,1,1,1,1,0,1],
[1,0,0,0,0,1,1,0],
[0,1,0,0,0,0,1,1],
[1,0,0,1,1,0,0,1],
[1,1,1,1,0,1,0,0],
[0,1,1,1,1,0,1,0],
[0,0,1,1,1,1,0,1],
[1,0,1,0,0,1,1,0],
[0,1,0,1,0,0,1,1],
[1,0,0,1,0,0,0,1],
[1,1,1,1,0,0,0,0],
[0,1,1,1,1,0,0,0],
[0,0,1,1,1,1,0,0],
[0,0,0,1,1,1,1,0],
[0,0,0,0,1,1,1,1],
[1,0,1,1,1,1,1,1],
[1,1,1,0,0,1,1,1],
[1,1,0,0,1,0,1,1],
[1,1,0,1,1,1,0,1],
[1,1,0,1,0,1,1,0],
[0,1,1,0,1,0,1,1],
[1,0,0,0,1,1,0,1],
[1,1,1,1,1,1,1,0],
[0,1,1,1,1,1,1,1],
[1,0,0,0,0,1,1,1],
[1,1,1,1,1,0,1,1],
[1,1,0,0,0,1,0,1],
[1,1,0,1,1,0,1,0],
[0,1,1,0,1,1,0,1],
[1,0,0,0,1,1,1,0],
[0,1,0,0,0,1,1,1],
[1,0,0,1,1,0,1,1],
[1,1,1,1,0,1,0,1],
[1,1,0,0,0,0,1,0],
[0,1,1,0,0,0,0,1],
[1,0,0,0,1,0,0,0],
[0,1,0,0,0,1,0,0],
[0,0,1,0,0,0,1,0],
[0,0,0,1,0,0,0,1],
[1,0,1,1,0,0,0,0],
[0,1,0,1,1,0,0,0],
[0,0,1,0,1,1,0,0],
[0,0,0,1,0,1,1,0],
[0,0,0,0,1,0,1,1],
[1,0,1,1,1,1,0,1],
[1,1,1,0,0,1,1,0],
[0,1,1,1,0,0,1,1],
[1,0,0,0,0,0,0,1],
[1,1,1,1,1,0,0,0],
[0,1,1,1,1,1,0,0],
[0,0,1,1,1,1,1,0],
[0,0,0,1,1,1,1,1],
[1,0,1,1,0,1,1,1],
[1,1,1,0,0,0,1,1],
[1,1,0,0,1,0,0,1],
[1,1,0,1,1,1,0,0],
[0,1,1,0,1,1,1,0],
[0,0,1,1,0,1,1,1],
[1,0,1,0,0,0,1,1],
[1,1,1,0,1,0,0,1],
[1,1,0,0,1,1,0,0],
[0,1,1,0,0,1,1,0],
[0,0,1,1,0,0,1,1],
[1,0,1,0,0,0,0,1],
[1,1,1,0,1,0,0,0],
[0,1,1,1,0,1,0,0],
[0,0,1,1,1,0,1,0],
[0,0,0,1,1,1,0,1],
[1,0,1,1,0,1,1,0],
[0,1,0,1,1,0,1,1],
[1,0,0,1,0,1,0,1]], dtype = int ) 

p256 = numpy.array(
[[1,0,0,0,1,0,0,0,0],
[0,1,0,0,0,1,0,0,0],
[0,0,1,0,0,0,1,0,0],
[0,0,0,1,0,0,0,1,0],
[0,0,0,0,1,0,0,0,1],
[1,0,0,0,1,1,0,0,0],
[0,1,0,0,0,1,1,0,0],
[0,0,1,0,0,0,1,1,0],
[0,0,0,1,0,0,0,1,1],
[1,0,0,0,0,0,0,0,1],
[1,1,0,0,1,0,0,0,0],
[0,1,1,0,0,1,0,0,0],
[0,0,1,1,0,0,1,0,0],
[0,0,0,1,1,0,0,1,0],
[0,0,0,0,1,1,0,0,1],
[1,0,0,0,1,1,1,0,0],
[0,1,0,0,0,1,1,1,0],
[0,0,1,0,0,0,1,1,1],
[1,0,0,1,1,0,0,1,1],
[1,1,0,0,0,1,0,0,1],
[1,1,1,0,1,0,1,0,0],
[0,1,1,1,0,1,0,1,0],
[0,0,1,1,1,0,1,0,1],
[1,0,0,1,0,1,0,1,0],
[0,1,0,0,1,0,1,0,1],
[1,0,1,0,1,1,0,1,0],
[0,1,0,1,0,1,1,0,1],
[1,0,1,0,0,0,1,1,0],
[0,1,0,1,0,0,0,1,1],
[1,0,1,0,0,0,0,0,1],
[1,1,0,1,1,0,0,0,0],
[0,1,1,0,1,1,0,0,0],
[0,0,1,1,0,1,1,0,0],
[0,0,0,1,1,0,1,1,0],
[0,0,0,0,1,1,0,1,1],
[1,0,0,0,1,1,1,0,1],
[1,1,0,0,1,1,1,1,0],
[0,1,1,0,0,1,1,1,1],
[1,0,1,1,1,0,1,1,1],
[1,1,0,1,0,1,0,1,1],
[1,1,1,0,0,0,1,0,1],
[1,1,1,1,1,0,0,1,0],
[0,1,1,1,1,1,0,0,1],
[1,0,1,1,0,1,1,0,0],
[0,1,0,1,1,0,1,1,0],
[0,0,1,0,1,1,0,1,1],
[1,0,0,1,1,1,1,0,1],
[1,1,0,0,0,1,1,1,0],
[0,1,1,0,0,0,1,1,1],
[1,0,1,1,1,0,0,1,1],
[1,1,0,1,0,1,0,0,1],
[1,1,1,0,0,0,1,0,0],
[0,1,1,1,0,0,0,1,0],
[0,0,1,1,1,0,0,0,1],
[1,0,0,1,0,1,0,0,0],
[0,1,0,0,1,0,1,0,0],
[0,0,1,0,0,1,0,1,0],
[0,0,0,1,0,0,1,0,1],
[1,0,0,0,0,0,0,1,0],
[0,1,0,0,0,0,0,0,1],
[1,0,1,0,1,0,0,0,0],
[0,1,0,1,0,1,0,0,0],
[0,0,1,0,1,0,1,0,0],
[0,0,0,1,0,1,0,1,0],
[0,0,0,0,1,0,1,0,1],
[1,0,0,0,1,1,0,1,0],
[0,1,0,0,0,1,1,0,1],
[1,0,1,0,1,0,1,1,0],
[0,1,0,1,0,1,0,1,1],
[1,0,1,0,0,0,1,0,1],
[1,1,0,1,1,0,0,1,0],
[0,1,1,0,1,1,0,0,1],
[1,0,1,1,1,1,1,0,0],
[0,1,0,1,1,1,1,1,0],
[0,0,1,0,1,1,1,1,1],
[1,0,0,1,1,1,1,1,1],
[1,1,0,0,0,1,1,1,1],
[1,1,1,0,1,0,1,1,1],
[1,1,1,1,1,1,0,1,1],
[1,1,1,1,0,1,1,0,1],
[1,1,1,1,0,0,1,1,0],
[0,1,1,1,1,0,0,1,1],
[1,0,1,1,0,1,0,0,1],
[1,1,0,1,0,0,1,0,0],
[0,1,1,0,1,0,0,1,0],
[0,0,1,1,0,1,0,0,1],
[1,0,0,1,0,0,1,0,0],
[0,1,0,0,1,0,0,1,0],
[0,0,1,0,0,1,0,0,1],
[1,0,0,1,1,0,1,0,0],
[0,1,0,0,1,1,0,1,0],
[0,0,1,0,0,1,1,0,1],
[1,0,0,1,1,0,1,1,0],
[0,1,0,0,1,1,0,1,1],
[1,0,1,0,1,1,1,0,1],
[1,1,0,1,1,1,1,1,0],
[0,1,1,0,1,1,1,1,1],
[1,0,1,1,1,1,1,1,1],
[1,1,0,1,0,1,1,1,1],
[1,1,1,0,0,0,1,1,1],
[1,1,1,1,1,0,0,1,1],
[1,1,1,1,0,1,0,0,1],
[1,1,1,1,0,0,1,0,0],
[0,1,1,1,1,0,0,1,0],
[0,0,1,1,1,1,0,0,1],
[1,0,0,1,0,1,1,0,0],
[0,1,0,0,1,0,1,1,0],
[0,0,1,0,0,1,0,1,1],
[1,0,0,1,1,0,1,0,1],
[1,1,0,0,0,1,0,1,0],
[0,1,1,0,0,0,1,0,1],
[1,0,1,1,1,0,0,1,0],
[0,1,0,1,1,1,0,0,1],
[1,0,1,0,0,1,1,0,0],
[0,1,0,1,0,0,1,1,0],
[0,0,1,0,1,0,0,1,1],
[1,0,0,1,1,1,0,0,1],
[1,1,0,0,0,1,1,0,0],
[0,1,1,0,0,0,1,1,0],
[0,0,1,1,0,0,0,1,1],
[1,0,0,1,0,0,0,0,1],
[1,1,0,0,0,0,0,0,0],
[0,1,1,0,0,0,0,0,0],
[0,0,1,1,0,0,0,0,0],
[0,0,0,1,1,0,0,0,0],
[0,0,0,0,1,1,0,0,0],
[0,0,0,0,0,1,1,0,0],
[0,0,0,0,0,0,1,1,0],
[0,0,0,0,0,0,0,1,1],
[1,0,0,0,1,0,0,0,1],
[1,1,0,0,1,1,0,0,0],
[0,1,1,0,0,1,1,0,0],
[0,0,1,1,0,0,1,1,0],
[0,0,0,1,1,0,0,1,1],
[1,0,0,0,0,1,0,0,1],
[1,1,0,0,1,0,1,0,0],
[0,1,1,0,0,1,0,1,0],
[0,0,1,1,0,0,1,0,1],
[1,0,0,1,0,0,0,1,0],
[0,1,0,0,1,0,0,0,1],
[1,0,1,0,1,1,0,0,0],
[0,1,0,1,0,1,1,0,0],
[0,0,1,0,1,0,1,1,0],
[0,0,0,1,0,1,0,1,1],
[1,0,0,0,0,0,1,0,1],
[1,1,0,0,1,0,0,1,0],
[0,1,1,0,0,1,0,0,1],
[1,0,1,1,1,0,1,0,0],
[0,1,0,1,1,1,0,1,0],
[0,0,1,0,1,1,1,0,1],
[1,0,0,1,1,1,1,1,0],
[0,1,0,0,1,1,1,1,1],
[1,0,1,0,1,1,1,1,1],
[1,1,0,1,1,1,1,1,1],
[1,1,1,0,0,1,1,1,1],
[1,1,1,1,1,0,1,1,1],
[1,1,1,1,0,1,0,1,1],
[1,1,1,1,0,0,1,0,1],
[1,1,1,1,0,0,0,1,0],
[0,1,1,1,1,0,0,0,1],
[1,0,1,1,0,1,0,0,0],
[0,1,0,1,1,0,1,0,0],
[0,0,1,0,1,1,0,1,0],
[0,0,0,1,0,1,1,0,1],
[1,0,0,0,0,0,1,1,0],
[0,1,0,0,0,0,0,1,1],
[1,0,1,0,1,0,0,0,1],
[1,1,0,1,1,1,0,0,0],
[0,1,1,0,1,1,1,0,0],
[0,0,1,1,0,1,1,1,0],
[0,0,0,1,1,0,1,1,1],
[1,0,0,0,0,1,0,1,1],
[1,1,0,0,1,0,1,0,1],
[1,1,1,0,1,1,0,1,0],
[0,1,1,1,0,1,1,0,1],
[1,0,1,1,0,0,1,1,0],
[0,1,0,1,1,0,0,1,1],
[1,0,1,0,0,1,0,0,1],
[1,1,0,1,1,0,1,0,0],
[0,1,1,0,1,1,0,1,0],
[0,0,1,1,0,1,1,0,1],
[1,0,0,1,0,0,1,1,0],
[0,1,0,0,1,0,0,1,1],
[1,0,1,0,1,1,0,0,1],
[1,1,0,1,1,1,1,0,0],
[0,1,1,0,1,1,1,1,0],
[0,0,1,1,0,1,1,1,1],
[1,0,0,1,0,0,1,1,1],
[1,1,0,0,0,0,0,1,1],
[1,1,1,0,1,0,0,0,1],
[1,1,1,1,1,1,0,0,0],
[0,1,1,1,1,1,1,0,0],
[0,0,1,1,1,1,1,1,0],
[0,0,0,1,1,1,1,1,1],
[1,0,0,0,0,1,1,1,1],
[1,1,0,0,1,0,1,1,1],
[1,1,1,0,1,1,0,1,1],
[1,1,1,1,1,1,1,0,1],
[1,1,1,1,0,1,1,1,0],
[0,1,1,1,1,0,1,1,1],
[1,0,1,1,0,1,0,1,1],
[1,1,0,1,0,0,1,0,1],
[1,1,1,0,0,0,0,1,0],
[0,1,1,1,0,0,0,0,1],
[1,0,1,1,0,0,0,0,0],
[0,1,0,1,1,0,0,0,0],
[0,0,1,0,1,1,0,0,0],
[0,0,0,1,0,1,1,0,0],
[0,0,0,0,1,0,1,1,0],
[0,0,0,0,0,1,0,1,1],
[1,0,0,0,1,0,1,0,1],
[1,1,0,0,1,1,0,1,0],
[0,1,1,0,0,1,1,0,1],
[1,0,1,1,1,0,1,1,0],
[0,1,0,1,1,1,0,1,1],
[1,0,1,0,0,1,1,0,1],
[1,1,0,1,1,0,1,1,0],
[0,1,1,0,1,1,0,1,1],
[1,0,1,1,1,1,1,0,1],
[1,1,0,1,0,1,1,1,0],
[0,1,1,0,1,0,1,1,1],
[1,0,1,1,1,1,0,1,1],
[1,1,0,1,0,1,1,0,1],
[1,1,1,0,0,0,1,1,0],
[0,1,1,1,0,0,0,1,1],
[1,0,1,1,0,0,0,0,1],
[1,1,0,1,0,0,0,0,0],
[0,1,1,0,1,0,0,0,0],
[0,0,1,1,0,1,0,0,0],
[0,0,0,1,1,0,1,0,0],
[0,0,0,0,1,1,0,1,0],
[0,0,0,0,0,1,1,0,1],
[1,0,0,0,1,0,1,1,0],
[0,1,0,0,0,1,0,1,1],
[1,0,1,0,1,0,1,0,1],
[1,1,0,1,1,1,0,1,0],
[0,1,1,0,1,1,1,0,1],
[1,0,1,1,1,1,1,1,0],
[0,1,0,1,1,1,1,1,1],
[1,0,1,0,0,1,1,1,1],
[1,1,0,1,1,0,1,1,1],
[1,1,1,0,0,1,0,1,1],
[1,1,1,1,1,0,1,0,1],
[1,1,1,1,0,1,0,1,0],
[0,1,1,1,1,0,1,0,1],
[1,0,1,1,0,1,0,1,0],
[0,1,0,1,1,0,1,0,1],
[1,0,1,0,0,1,0,1,0],
[0,1,0,1,0,0,1,0,1],
[1,0,1,0,0,0,0,1,0],
[0,1,0,1,0,0,0,0,1],
[1,0,1,0,0,0,0,0,0],
[0,1,0,1,0,0,0,0,0],
[0,0,1,0,1,0,0,0,0],
[0,0,0,1,0,1,0,0,0],
[0,0,0,0,1,0,1,0,0]], dtype = int) #P256 = 256X9 parity submatrix 

g16 = numpy.concatenate((numpy.eye(16,dtype=int),p16), axis = 1)  

h16 = numpy.concatenate((numpy.transpose(p16), numpy.eye(5, dtype=int)), axis = 1) 

g32 = numpy.concatenate((numpy.eye(32,dtype=int),p32), axis = 1)  

h32 = numpy.concatenate((numpy.transpose(p32), numpy.eye(6, dtype=int)), axis = 1) 

g64 = numpy.concatenate((numpy.eye(64,dtype=int),p64), axis = 1) 
h64 = numpy.concatenate((numpy.transpose(p64), numpy.eye(7, dtype=int)), axis = 1)  

g128 = numpy.concatenate((numpy.eye(128,dtype=int),p128), axis = 1) 
h128 = numpy.concatenate((numpy.transpose(p128), numpy.eye(8, dtype=int)), axis = 1) 

g256 = numpy.concatenate((numpy.eye(256,dtype=int), p256), axis = 1) 
h256 = numpy.concatenate((numpy.transpose(p256), numpy.eye(9, dtype=int)), axis = 1)   

gentable = {16:g16,32:g32, 64:g64, 128:g128, 256:g256} 
partable = {16:h16, 32:h32, 64:h64, 128:h128, 256:h256} 
 
def createMessage(length):
    """
    randomly create original information bits 
    input: information length 
    output: a numpy array vector 

     """
    msg = []
    for i in range(length):
        letter = random.choice([0,1])
        msg.append(letter)
    return numpy.array(msg, dtype = int)
 
def encode(m, g): 
    "encoder by Generator matrix g.  m * G = c , works on SEC part ; Return a numpy array "
    enc = numpy.dot(m, g)%2
    return enc
 
def syndrome(received, h):
    "syndrome calculation syn = r x H' or H x r' = syn' , return a numpy array"
    synd = numpy.dot(h, received)%2
    return synd
 
def noise(m, error, bit):
    "error is error rate, bit is total #corrupted bits,m is the input vector; insert noise in the message; out: a numpy array"
    noisy_msg = numpy.copy(m)
    cont = 0
    for i in range(len(noisy_msg)):
        e = random.random() # return a random number in [0,1)
        if e <= error:
            if noisy_msg[i] == 0:
                noisy_msg[i] = 1
                cont +=1
            else:
                noisy_msg[i] = 0
                cont +=1
            if cont == bit:  # bit is  #corrupted bits
                break
    return noisy_msg #return noise mask 
 
def findError(synd, H_matrix):
    # need to altered by Colin , return the location index of error, works on the SEC part  
    "error locator function. return the position of error"
    if all(synd==0):
        return -1 # no error , clean syndrome returns -1 
    block_length = int(H_matrix.shape[1]) # H is a rxn matrix, so n is the code length 
    e = numpy.zeros(block_length,int) 
    for i in xrange(0,block_length):
        e1 = numpy.copy(e)  #copy original zeros vector
        e1[i] = 1
        compare = numpy.dot(e1,H_matrix.transpose()) 
        if numpy.array_equal(compare,synd):
            return i # locator index 
        else:
            continue 
    else:
        return 1000 # beyond correction capability        
 
def correct(noisy, n):
    "flip bits at n-th position. return : a numpy.array "
    # copy the received vector first 
    recv = numpy.copy(noisy)
    if recv[n] == 0:
        recv[n] = 1
    else:# recv[n] == 1:
        recv[n] = 0
    #print recv
    return recv
 
def hamming(length, n, error, bit):
    # g =  numpy.array([[1, 0, 0, 0, 0, 1, 1],[0, 1, 0, 0, 1, 0, 1],[0, 0, 1, 0, 1, 1, 0],[0, 0, 0, 1, 1, 1, 1]])
    # h = numpy.array([[0, 0, 0, 1, 1, 1, 1],[0, 1, 1, 0, 0, 1, 1],[1, 0, 1, 0, 1, 0, 1]]) # colin. remove a extra , comma
    assert length in (16,32,64,128,256) 
    g = gentable[length]
    h = partable[length] 
    # corrected = 0
    # uncorrected = 0
    for i in range(n): # n incoming received message repetitions 
        msg = createMessage(length) # generate a random information vector u(x)
        enc = encode(msg, g) 

        # ------- check parity right after encoder : parity before corruption ----------
        op_before =  list(enc).count(1) % 2 
        print "original message: ", msg, " parity: ",op_before 
        print "encoded msg: ", enc

        # ------introduce corruption --------------
        noisy = noise(enc, error, bit)

        #------check parity after corruption --------
        op_after = list(noisy).count(1) % 2 
        # --------DED_flag denotes the status of DED part, 1 means detected parity mismatch -- --
        DED_flag = op_before ^ op_after 
        print 'received mesage: ', noisy," parity(after pollution): ", op_after 
        # -----compute syndrome , set the SEC flag ------------------------------
        syndromes = syndrome(noisy, h)
        print 'syndrome vector: ', syndromes
         # -------- error pattern / error location returned if only 1 error bit, if clean, error_index = -1 ----
        error_index = findError(syndromes, h) 

        SEC_flag = int(error_index >= 0)  # SEC_flag 1 denotes error alert in SEC part 

        # create a error status code , a tuple of SEC and DED flags 
        ERROR_STATUS_CODE = (SEC_flag,DED_flag)  

        #---------------CORRECTION ACTION AS PER THE STATUS OF (SEC_FLAG,DED_FLAG) ----------
        # ------------------------------------------------------------------------------------
        if ERROR_STATUS_CODE == (0,0):
            print 'Clean! No errors !'
        elif ERROR_STATUS_CODE == (1,1):
            corrected_vector = correct(noisy, error_index)
            print 'corrected vector : ', corrected_vector
            if numpy.array_equal(corrected_vector, enc):
                print 'correction success!!!'
            else:
                print 'mis-correction...'
        elif ERROR_STATUS_CODE == (1,0):
            print "2 errors detected! Unable to correct! " 
        else:
            print "The impossible occurs, something wrong! "


        


        # if error_index >= 0 and error_index < 1000:
        #     corrected_vector = correct(noisy,error_index)
        #     print 'corrected vector is ',corrected_vector 
        # else: # if synd = 0 
        #     print 'no error detected!' 





        
        
if __name__ == '__main__':

    
        
    
    length = int(raw_input('word width [must be valid]: '))
    n = int(raw_input('Repetitions: '))
    ber = float(raw_input('bit error rate: '))
    nerr = int(raw_input('maximum number of errors: '))
    hamming(length,n,ber, nerr)











